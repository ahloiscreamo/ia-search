#!/bin/bash
# üé¨ ia-search ‚Äî Interactive Internet Archive browser & downloader
# Features: Top Collections paging, caching, vim text viewer, search mode with smart Esc, and smooth transitions.

# --- Player Config ---
VIDEO_PLAYER="mpv"
AUDIO_PLAYER="mpv"
IMAGE_VIEWER="nsxiv"
PDF_VIEWER="zathura"
VIDEO_DOWNLOADER="yt-dlp"

# --- API Config ---
API_URL="https://archive.org/advancedsearch.php"

# --- Cache Config ---
CACHE_FILE="$HOME/.cache/ia-search-collections.json"
mkdir -p "$(dirname "$CACHE_FILE")"
CACHE_EXPIRY=$((60*60*24))  # 24 hours




# --- Dependency Check ---
check_deps() {
    local missing=0
    for cmd in fzf jq curl ia pv mpv nsxiv zathura yt-dlp; do
        if ! command -v "$cmd" &> /dev/null; then
            echo "‚ùå Error: Required command '$cmd' is not installed."
            missing=1
        fi
    done
    [ "$missing" -eq 1 ] && exit 1
}

# --- Helper: Download and View ---
download_and_view() {
    local url="$1"
    local viewer="$2"
    local temp_file
    temp_file=$(mktemp)
    # Ensure temp file is removed on exit/interrupt
    trap 'rm -f "$temp_file"' INT TERM EXIT

    echo "‚è≥ Downloading to view..."
    curl -sL "$url" | pv > "$temp_file"

    if [ -s "$temp_file" ]; then
        # Run viewer in the background and clean up afterwards
        ( "$viewer" "$temp_file" >/dev/null 2>&1; rm -f "$temp_file" ) &
    else
        echo "üö´ Failed to download file for viewing."
        rm -f "$temp_file"
    fi
    # Clear the trap so it doesn't fire on successful exit from this function
    trap - INT TERM EXIT
}

# --- URL Encode ---
urlencode() {
    local string="${1}"
    local strlen=${#string}
    local encoded=""
    local pos c

    for (( pos=0 ; pos<strlen ; pos++ )); do
        c=${string:$pos:1}
        case "$c" in
            [-_.~a-zA-Z0-9] ) o="${c}" ;;
            * )               printf -v o '%%%02x' "'$c"
        esac
        encoded+="${o}"
    done
    echo "${encoded}"
}

# --- Show Collections ---
show_collections() {
    local PAGE_SIZE=50
    local page=0

    fetch_collections() {
        echo "üìö Fetching top collections from Internet Archive..."
        local fetched_json
        fetched_json=$(curl -sG "$API_URL" \
            --data-urlencode "q=mediatype:collection" \
            --data-urlencode "fl[]=identifier" \
            --data-urlencode "fl[]=title" \
            --data-urlencode "fl[]=description" \
            --data-urlencode "sort[]=downloads desc" \
            --data-urlencode "rows=500" \
            --data-urlencode "output=json")
        
        if [ $? -ne 0 ] || [ -z "$fetched_json" ]; then
            echo "‚ùå Error: Failed to fetch collections from the Internet Archive."
            return 1
        fi

        if ! echo "$fetched_json" | jq -e . >/dev/null 2>&1; then
            echo "‚ùå Error: Corrupt response received from the API."
            return 1
        fi
        
        json="$fetched_json" # Update parent scope variable
        echo "$json" > "$CACHE_FILE"
        return 0
    }

    if [ -f "$CACHE_FILE" ] && [ $(( $(date +%s) - $(stat -c %Y "$CACHE_FILE") )) -lt $CACHE_EXPIRY ]; then
        echo "üìö Loading collections from cache..."
        json=$(cat "$CACHE_FILE")
    else
        if ! fetch_collections; then
            echo "üëã Exiting due to network error."
            exit 1
        fi
    fi

    mapfile -t all_entries < <(echo "$json" | jq -r '.response.docs[] | "\(.title) [\(.identifier)]"')
    local total_pages=$(( (${#all_entries[@]} + PAGE_SIZE - 1) / PAGE_SIZE ))

    while true; do
        local start=$(( page * PAGE_SIZE ))
        local end=$(( start + PAGE_SIZE - 1 ))
        [ $end -ge ${#all_entries[@]} ] && end=$((${#all_entries[@]} - 1))

        local page_entries=("${all_entries[@]:start:end-start+1}")

        choices=("[üîç Search all collections]" "[üîÑ Refresh cache]" "")
        choices+=("${page_entries[@]}")
        choices+=("" "[‚û°Ô∏è Next page]" "[‚ùå Exit]")

        selection=$(printf '%s\n' "${choices[@]}" | fzf \
            --prompt="üìÇ Select collection (Page $((page+1))/$total_pages) > " \
            --height=100% \
            --reverse \
            --border)

        case "$selection" in
            "[üîÑ Refresh cache]")
                fetch_collections
                mapfile -t all_entries < <(echo "$json" | jq -r '.response.docs[] | "\(.title) [\(.identifier)]"')
                total_pages=$(( (${#all_entries[@]} + PAGE_SIZE - 1) / PAGE_SIZE ))
                page=0
                echo "‚úÖ Cache refreshed."
                ;;
            "[üîç Search all collections]")
                search_mode
                continue
                ;;
            "[‚û°Ô∏è Next page]")
                ((page++))
                if [ $page -ge $total_pages ]; then
                    page=$((total_pages - 1))
                fi
                ;;
            "[‚ùå Exit]"|"")
                echo "üëã Exiting."
                exit 0
                ;;
            *)
                collection=$(echo "$selection" | sed -E 's/.*\[(.*)\]$/\1/')
                browse_collection "$collection"
                ;;
        esac
    done
}

# --- Search Mode ---
search_mode() {
    local query identifier_or_action page rows item_json selected_line
    local -a choices items

    # This preview command now includes the original's simple check for an empty line.
    local preview_command='bash -c '\''
        item_text="$1"
        # If the line is empty, do nothing (this handles the gap/space)
        if [ -z "$item_text" ]; then
            :
        elif [[ "$item_text" == "["* && "$item_text" == *"]"* ]]; then
            echo "Navigate with Enter. No item preview for options."
        else
            ia list "$item_text" | head -n 20
        fi
    '\'' _ {1}'

    while true; do
        query=$(printf '' | fzf --prompt="üîç Type search query (ESC to return to main) > " --print-query --height=10 --reverse --border | head -n1)
        [ -z "$query" ] && return 0

        page=1
        rows=30

        while true; do
            echo "üîé Searching for \"$query\" (Page $page)..."
            
            item_json=$(ia search "$query" --field identifier --field title --sort="downloads desc" -p "page:$page" -p "rows:$rows")
            if [ -z "$item_json" ]; then
                echo "üö´ No results found for page $page."
                if [ "$page" -eq 1 ]; then break; fi
            fi
            
            # Format as: identifier<TAB>title
            mapfile -t items < <(echo "$item_json" | jq -s -r '.[] | "\(.identifier)\t\(.title)"')

            # Build choices with uniform ID<TAB>TEXT format
            choices=()
            
            if [ "${#items[@]}" -eq "$rows" ]; then
                choices+=("[‚û°Ô∏è Next page]	[‚û°Ô∏è Next page]")
            fi
            if [ "$page" -gt 1 ]; then
                 choices+=("[‚¨ÖÔ∏è Previous page]	[‚¨ÖÔ∏è Previous page]")
            fi
            choices+=("[üîç Search all results]	[üîç Search all results]")

            # Use a simple empty string for the gap, like the original script
            if [ "${#choices[@]}" -gt 0 ]; then
                choices+=("")
            fi

            choices+=("${items[@]}")

            selected_line=$(printf '%s\n' "${choices[@]}" | fzf \
                --prompt="üé• Select title from '$query' (Page $page) > " \
                --height=100% \
                --reverse \
                --border \
                --delimiter=$'\t' \
                --with-nth=2.. \
                --preview-window=right:40% \
                --preview "$preview_command")
            
            identifier_or_action=$(echo "$selected_line" | awk -F'\t' '{print $1}')

            if [ -z "$identifier_or_action" ]; then
                break
            fi

            case "$identifier_or_action" in
                "[‚û°Ô∏è Next page]")
                    ((page++))
                    ;;
                "[‚¨ÖÔ∏è Previous page]")
                    if [ "$page" -gt 1 ]; then
                        ((page--))
                    fi
                    ;;
                "[üîç Search all results]")
                    local sub_query_text
                    sub_query_text=$(printf '' | fzf --prompt="üîé Search within results for '$query': " --print-query --height=10 --reverse --border | head -n1)
                    [ -z "$sub_query_text" ] && continue

                    echo "üîé Searching for \"$query AND $sub_query_text\"..."
                    local combined_query="$query AND $sub_query_text"
                    local total_combined_hits
                    total_combined_hits=$(ia search "$combined_query" --num-found)

                    if [ -z "$total_combined_hits" ] || [ "$total_combined_hits" -eq 0 ]; then
                        echo "üö´ No results found for \"$combined_query\"."
                        continue
                    fi

                    echo "üîé Loading all $total_combined_hits results for \"$combined_query\"..."
                    
                    local temp_combined_file
                    temp_combined_file=$(mktemp)
                    (ia search "$combined_query" --field identifier --field title | pv -l -s "$total_combined_hits" -N "Loading combined" > "$temp_combined_file")
                    
                    local selected_sub_item_line
                    selected_sub_item_line=$(cat "$temp_combined_file" | jq -s -r '.[] | "\(.identifier)\t\(.title)"' | fzf \
                        --prompt="üé• Results for '$combined_query' > " \
                        --height=100% \
                        --reverse \
                        --border \
                        --delimiter=$'\t' \
                        --with-nth=2.. \
                        --preview-window=right:40% \
                        --preview "$preview_command")
                    
                    rm "$temp_combined_file"

                    if [ -n "$selected_sub_item_line" ]; then
                        local final_identifier
                        final_identifier=$(echo "$selected_sub_item_line" | awk 'BEGIN{FS="\t"} {print $1}')
                        open_item "$final_identifier"
                    fi
                    break
                    ;;
                *)
                    open_item "$identifier_or_action"
                    ;;
            esac
        done
    done
}

# --- Browse Collection ---
browse_collection() {
    local coll="$1"
    local identifier_or_action page rows item_json selected_line
    local -a choices items
    
    # This preview command now includes the original's simple check for an empty line.
    local preview_command='bash -c '\''
        item_text="$1"
        # If the line is empty, do nothing (this handles the gap/space)
        if [ -z "$item_text" ]; then
            :
        elif [[ "$item_text" == "["* && "$item_text" == *"]"* ]]; then
            echo "Navigate with Enter. No item preview for options."
        else
            ia list "$item_text" | head -n 20
        fi
    '\'' _ {1}'

    page=1
    rows=30

    while true; do
        echo "üìÅ Browsing collection: $coll (Page $page)..."

        item_json=$(ia search "collection:$coll" --field identifier --field title --sort="downloads desc" -p "page:$page" -p "rows:$rows")
        if [ -z "$item_json" ]; then
            echo "üö´ No results found for page $page."
            if [ "$page" -eq 1 ]; then break; fi
        fi

        mapfile -t items < <(echo "$item_json" | jq -s -r '.[] | "\(.identifier)\t\(.title)"')

        # Build choices with uniform ID<TAB>TEXT format
        choices=()
        
        if [ "${#items[@]}" -eq "$rows" ]; then
            choices+=("[‚û°Ô∏è Next page]	[‚û°Ô∏è Next page]")
        fi
        if [ "$page" -gt 1 ]; then
            choices+=("[‚¨ÖÔ∏è Previous page]	[‚¨ÖÔ∏è Previous page]")
        fi
        choices+=("[üîç Search all results]	[üîç Search all results]")

        # Use a simple empty string for the gap, like the original script
        if [ "${#choices[@]}" -gt 0 ]; then
            choices+=("")
        fi

        choices+=("${items[@]}")

        selected_line=$(printf '%s\n' "${choices[@]}" | fzf \
            --prompt="üéûÔ∏è Select title from $coll (Page $page) > " \
            --height=100% \
            --reverse \
            --border \
            --delimiter=$'\t' \
            --with-nth=2.. \
            --preview-window=right:40% \
            --preview "$preview_command")

        identifier_or_action=$(echo "$selected_line" | awk -F'\t' '{print $1}')

        if [ -z "$identifier_or_action" ]; then
            return
        fi

        case "$identifier_or_action" in
            "[‚û°Ô∏è Next page]")
                ((page++))
                ;;
            "[‚¨ÖÔ∏è Previous page]")
                if [ "$page" -gt 1 ]; then
                    ((page--))
                fi
                ;;
            "[üîç Search all results]")
                local sub_query_text
                sub_query_text=$(printf '' | fzf --prompt="üîé Search within collection '$coll': " --print-query --height=10 --reverse --border | head -n1)
                [ -z "$sub_query_text" ] && continue

                echo "üîé Searching for \"collection:$coll AND $sub_query_text\"..."
                local combined_query="collection:$coll AND $sub_query_text"
                local total_combined_hits
                total_combined_hits=$(ia search "$combined_query" --num-found)

                if [ -z "$total_combined_hits" ] || [ "$total_combined_hits" -eq 0 ]; then
                    echo "üö´ No results found for \"$combined_query\"."
                    continue
                fi

                echo "üîé Loading all $total_combined_hits results for \"$combined_query\"..."
                
                local temp_combined_file
                temp_combined_file=$(mktemp)
                (ia search "$combined_query" --field identifier --field title | pv -l -s "$total_combined_hits" -N "Loading combined" > "$temp_combined_file")
                
                local selected_sub_item_line
                selected_sub_item_line=$(cat "$temp_combined_file" | jq -s -r '.[] | "\(.identifier)\t\(.title)"' | fzf \
                        --prompt="üé• Results for '$combined_query' > " \
                        --height=100% \
                        --reverse \
                        --border \
                        --delimiter=$'\t' \
                        --with-nth=2.. \
                        --preview-window=right:40% \
                        --preview "$preview_command")
                
                rm "$temp_combined_file"

                if [ -n "$selected_sub_item_line" ]; then
                    local final_identifier
                    final_identifier=$(echo "$selected_sub_item_line" | awk 'BEGIN{FS="\t"} {print $1}')
                    open_item "$final_identifier"
                fi
                return
                ;;
            " ")
                # This is the blank line, do nothing.
                ;;
            *)
                open_item "$identifier_or_action"
                return
                ;;
        esac
    done
}

# --- Open / Play / Download Item ---
open_item() {
    local identifier="$1"
    echo "üìÇ Fetching file list for: $identifier ..."
    file_list=$(ia list "$identifier")
    filename=$(echo "$file_list" | fzf --prompt="üìÅ Select a file to open > " --height=100% --reverse --border)
    [ -z "$filename" ] && echo "üö´ No file selected." && return

    case "$filename" in
        *.mp4|*.mkv|*.avi|*.webm|*.flv|*.ogv|*.mp3|*.ogg|*.flac|*.wav|*.m4a)
            action_label="‚ñ∂Ô∏è Play" ;;
        *) action_label="üìÇ Open" ;;
    esac

    action=$(echo -e "$action_label\n‚¨áÔ∏è Download" | fzf --prompt="üé¨ Choose action for $filename > " --height=100% --reverse --border)
    [ -z "$action" ] && echo "üö´ No action selected." && return

    filename_encoded=$(urlencode "$filename")
    url="https://archive.org/download/$identifier/$filename_encoded"

    if [ "$action" == "‚ñ∂Ô∏è Play" ] || [ "$action" == "üìÇ Open" ]; then
        case "$filename" in
            *.mp4|*.mkv|*.avi|*.webm|*.flv|*.ogv)
                echo "üéûÔ∏è Playing video..."
                video_basename=$(echo "$filename" | sed 's/\.[^.]*$//')
                
                sub_file=$(echo "$file_list" | grep -E "^${video_basename//./\\.}.*\\.(srt|ass)$" | head -n1)

                # Create a temporary log file to monitor mpv status
                mpv_log=$(mktemp)

                if [ -n "$sub_file" ]; then
                    sub_encoded=$(urlencode "$sub_file")
                    sub_url="https://archive.org/download/$identifier/$sub_encoded"
                    # Redirect stderr/stdout to log file so we can grep it
                    $VIDEO_PLAYER "$url" --sub-file="$sub_url" > "$mpv_log" 2>&1 &
                else
                    $VIDEO_PLAYER "$url" > "$mpv_log" 2>&1 &
                fi 
                
                pid=$!

                # --- Real-time Launch Monitor ---
                # This loop waits until mpv prints "VO:" (Video Output) or "AO:" (Audio Output) to the log.
                # This confirms that buffering is done and the window is actually ready.
                (
                    # Timeout after 200 ticks (approx 20 seconds) to prevent hanging on slow networks
                    for ((i=0; i<200; i++)); do
                        # If mpv crashes, stop waiting
                        if ! kill -0 "$pid" 2>/dev/null; then break; fi
                        
                        # Check the log for "VO:" or "AO:" (Success signals)
                        if grep -q -E "^(VO|AO):" "$mpv_log"; then break; fi
                        
                        echo -n "."
                        sleep 0.1
                    done
                ) | pv -p -t -e -N "üöÄ Launching mpv" -s 200 > /dev/null

                # Clean up
                rm -f "$mpv_log"
                ;;

            *.mp3|*.ogg|*.flac|*.wav|*.m4a)
                echo "üéß Playing audio..."
                $AUDIO_PLAYER "$url" >/dev/null 2>&1 & ;;
            *.png|*.jpg|*.jpeg|*.gif|*.bmp)
                download_and_view "$url" "$IMAGE_VIEWER" ;;
            *.pdf)
                download_and_view "$url" "$PDF_VIEWER" ;;
            *.txt|*.md|*.rst|*.csv|*.log|*.tex|*.sh|*.py|*.c|*.cpp|*.h|*.java|*.js|*.ts|*.json|*.xml|*.yaml|*.yml|*.ini|*.conf|*.cfg)
                temp_file=$(mktemp)
                curl -sL "$url" -o "$temp_file"
                if [ -s "$temp_file" ]; then
                    vim "$temp_file"
                    rm -f "$temp_file"
                else
                    echo "üö´ Failed to fetch $filename"
                fi ;;
            *)
                xdg-open "$url" >/dev/null 2>&1 &
                ;;
        esac
    elif [ "$action" == "‚¨áÔ∏è Download" ]; then
        case "$filename" in
            *.mp4|*.mkv|*.avi|*.webm|*.flv|*.ogv)
                $VIDEO_DOWNLOADER "$url" ;;
            *)
                curl -L -o "$filename" "$url" ;;
        esac
        echo "‚úÖ Done."
    fi
}

# --- Main ---
check_deps
show_collections
echo "üëã Goodbye."
exit 0
